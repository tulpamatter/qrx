<!DOCTYPE html>
<html>
<head>
  <style>:root{color-scheme:light dark}</style>
</head>
<body>
<script>;(async () => {
  // Basic setup and shorthands
  let d = document,
      b = d.body,
      g = k => localStorage.getItem(k)

  // Connect to IndexedDB, create stores if needed
  let db = await new Promise(r => {
    let R = indexedDB.open('os', 1)
    R.onupgradeneeded = e => {
      let s = e.target.result
      s.createObjectStore('f', { keyPath: 'k' })
      s.createObjectStore('h', { autoIncrement: true })
    }
    R.onsuccess = e => r(e.target.result)
  })

  // Database operation helpers: o(store, op), $r(read), $rf(read fuzzy)
  let o = (s, t, ...a) => new Promise(r => {
        db.transaction(s, 'readwrite').objectStore(s)[t](...a).onsuccess = e => r(e.target.result)
      }),
      $r = k => o('f', 'get', k).then(r => r?.value || ''),
      $rf = (P, wrap) => new Promise(async R => {
        let B = [],
            C = db.transaction('f').objectStore('f').openCursor(IDBKeyRange.bound(P, P + '\uffff'))
        C.onsuccess = e => {
          let c = e.target.result
          c ? (B.push(wrap ? `<context source="${c.key}">${c.value.value}</context>` : c.value.value), c.continue()) : R(B)
        }
      })

  // The main execution function, runs on load and hash change
  let run = async () => {
    // Log every URL change to history for auditability
    await o('h', 'add', { t: new Date(), u: location.href })

    // Parse page key ($p) and command string ($cmd) from URL
    let u = location.hash.slice(1),
        [$c, $cmd] = u.split('?'),
        $p = $c || 'home'

    // Initialize savable source ($s) and live accumulator ($a)
    let $s = await $r($p),
        $a = $s

    // Main command processing block
    if ($cmd) {
      // Initialize per-run state (model, keys, target, etc)
      let S = {
        h: g('h') || 'generativelanguage.googleapis.com',
        m: g('m') || 'gemini-2.5-flash',
        k: g('k'),
        s: '',
        t: $p
      }

      // Create an ordered queue of commands
      let cmds = $cmd.split('&')

      // Sequentially execute each command from the URL
      for (let cmd of cmds) {
        let [K, ...V] = cmd.split('='),
            v = decodeURIComponent(V.join('='))
        
        // State-setting commands modify the S object for subsequent actions
        if ('hmk'.includes(K)) S[K] = v
        else if (K === 's') S.s = v
        else if (K === 't') S.t = v || $p
        // Action commands transform the accumulator ($a) or source ($s)
        else if (K === 'w') { // 'w': Destructive write to source and accumulator
          $s = v
          $a = v
          await o('f', 'put', { k: S.t, value: $s })
        } else if (K === 'b') { // 'b': Prepend to accumulator (runtime only)
          if (v.endsWith('*')) {
            let P = v.slice(0, -1),
                B = await $rf(P)
            $a = B.join('\n') + $a
          } else {
            let B = await $r(v)
            $a = B + $a
          }
        } else if (K === 'x') { // 'x': Execute arbitrary JS with access to state
          eval(v)
        } else if (K === 'p') { // 'p': The main generative command
          let cc = $a,
              sp = '',
              pt = v,
              injs = v.match(/@[\w\/-]+\*?/g) || []

          // Gather system prompt (sp), supporting fuzzy search
          if (S.s) {
            if (S.s.endsWith('*')) {
              let P = S.s.slice(0, -1),
                  B = await $rf(P)
              sp = B.join('\n')
            } else {
              sp = await $r(S.s)
            }
          }

          // Process @-injections in the prompt text (pt)
          for (let inj of injs) {
            if (inj.endsWith('*')) {
              let P = inj.slice(1, -1),
                  B = await $rf(P, true)
              pt = pt.replace(inj, B.join('\n'))
            } else {
              let injKey = inj.slice(1),
                  injContent = await $r(injKey)
              pt = pt.replace(inj, injContent)
            }
          }

          // Assemble payload and call the LLM
          let B = {
            contents: [{
              parts: [{ text: `<system>${sp}</system><page>${cc}</page><prompt>${pt}</prompt>` }]
            }]
          }
          
          let Z = await fetch(`https://${S.h}/v1beta/models/${S.m}:generateContent?key=${S.k}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(B)
          })
          let j = await Z.json(),
              R = j.candidates[0].content.parts[0].text
          if (!Z.ok) throw j.error
          
          // Overwrite source and accumulator with the result
          $s = $a = R
          await o('f', 'put', { k: S.t, value: $s })
        }
      }
      // Clean the URL, removing commands after execution
      history.replaceState(null, '', `/#${$p}`)
    }

    // Paint the final, live accumulator state to the DOM
    b.innerHTML = $a
  }

  // Attach the executor to URL changes and run on initial load
  window.addEventListener('hashchange', run)
  run()
})()</script>
</body>
</html>