<!DOCTYPE html>
<html>
<head>
  <style>:root{color-scheme:light dark}</style>
</head>
<body>
<script>;(async () => {
  // Basic setup and shorthands
  let d = document,
      b = d.body,
      g = k => localStorage.getItem(k)

  // Connect to the IndexedDB database
  let db = await new Promise(r => {
    let R = indexedDB.open('os', 1)
    R.onupgradeneeded = e => {
      let s = e.target.result
      s.createObjectStore('f', { keyPath: 'k' })
      s.createObjectStore('h', { autoIncrement: true })
    }
    R.onsuccess = e => r(e.target.result)
  })

  // Database operation helpers
  let o = (s, t, ...a) => new Promise(r => {
        db.transaction(s, 'readwrite').objectStore(s)[t](...a).onsuccess = e => r(e.target.result)
      }),
      $r = k => o('f', 'get', k).then(r => r?.value || '')

  // The main execution function
  let run = async () => {
    // Log the current URL to the history before execution
    await o('h', 'add', { t: new Date(), u: location.href })

    // Parse the page key and command string from the URL
    let u = location.hash.slice(1),
        [$c, $cmd] = u.split('?'),
        $p = $c || 'home'

    // Initialize the two states
    let $s = await $r($p)      // The savable document content
    let $a = $s             // The live, in-memory content for this run

    // Main execution block, only runs if there are commands
    if ($cmd) {
      // Initialize the state for this command stream
      let S = {
        h: g('h') || 'generativelanguage.googleapis.com',
        m: g('m') || 'gemini-2.5-flash',
        k: g('k'),
        s: '',
        t: $p
      }

      // Create an ordered queue of commands
      let cmds = $cmd.split('&')

      // Loop through and execute each command
      for (let cmd of cmds) {
        let [K, ...V] = cmd.split('='),
            v = decodeURIComponent(V.join('='))
        
        // State-Setting Commands
        if ('hmks'.includes(K)) S[K] = v
        else if (K === 't') S.t = v || $p
        // Action Commands
        else if (K === 'w') {
          $s = v
          $a = v
          await o('f', 'put', { k: S.t, value: $s })
        } else if (K === 'b') {
          let B = await $r(v)
          $a = B + $a
        } else if (K === 'x') {
          eval(v)
        } else if (K === 'p') {
          let cc = $a
          let sp = await $r(S.s)
          let pt = v
          let injs = v.match(/@\w+/g) || []

          for (let inj of injs) {
            let injKey = inj.slice(1)
            let injContent = await $r(injKey)
            pt = pt.replace(inj, injContent)
          }

          let B = {
            contents: [{
              parts: [{ text: `<system>${sp}</system><page>${cc}</page><prompt>${pt}</prompt>` }]
            }]
          }
          
          let Z = await fetch(`https://${S.h}/v1beta/models/${S.m}:generateContent?key=${S.k}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(B)
          })
          let j = await Z.json()
          if (!Z.ok) throw j.error
          let R = j.candidates[0].content.parts[0].text
          
          $s = $a = R
          await o('f', 'put', { k: S.t, value: $s })
        }
      }
      // Clean the URL, removing commands
      history.replaceState(null, '', `/#${$p}`)
    }

    // Paint the final state of the accumulator to the DOM
    b.innerHTML = $a
  }

  // Listen for URL changes and run the executor
  window.addEventListener('hashchange', run)

  // Run the executor on initial page load
  run()
})()</script>
</body>
</html>